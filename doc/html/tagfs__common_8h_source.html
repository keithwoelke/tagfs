<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TagFS: src/tagfs_common.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>src/tagfs_common.h</h1>  </div>
</div>
<div class="contents">
<a href="tagfs__common_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00008"></a>00008 <span class="preprocessor">#ifndef TAGFS_COMMON_H</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor">#define TAGFS_COMMON_H</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span>
<a name="l00017"></a>00017 <span class="keywordtype">char</span> *get_file_directory(<span class="keywordtype">char</span> *file_path);
<a name="l00018"></a>00018 
<a name="l00025"></a>00025 <span class="keywordtype">int</span> num_digits(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num);
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 
<a name="l00040"></a>00040 <span class="comment">// * Identical to the standand printf, but outputs to stderr instead. Also forces the program to terminate execution.</span>
<a name="l00041"></a>00041 <span class="comment">// * @param format String that contains the text to be written to stderr. It can optionally contain embedded format tags that are substituted by the values specified in subsequent argument(s). In this respect, the function is identical to printf, but outputs to stderr instead.</span>
<a name="l00042"></a>00042 <span class="comment">// * @param additional Depending on the format string, the function may expect a sequence of additional arguments, each containing one value to be inserted instead of each %-tag specified in the format parameter, if any. There should be the same number of these arguments as the number of %-tags that expect a value.</span>
<a name="l00043"></a>00043 <span class="comment">// */</span>
<a name="l00044"></a>00044 <span class="comment">//void ERROR(char *error, ...);</span>
<a name="l00045"></a>00045 <span class="comment">//</span>
<a name="l00047"></a>00047 <span class="comment"></span><span class="comment">// * Identical to the standand printf, but outputs to stderr instead.</span>
<a name="l00048"></a>00048 <span class="comment">// * @param format String that contains the text to be written to stderr. It can optionally contain embedded format tags that are substituted by the values specified in subsequent argument(s). In this respect, the function is identical to printf, but outputs to stderr instead.</span>
<a name="l00049"></a>00049 <span class="comment">// * @param additional Depending on the format string, the function may expect a sequence of additional arguments, each containing one value to be inserted instead of each %-tag specified in the format parameter, if any. There should be the same number of these arguments as the number of %-tags that expect a value.</span>
<a name="l00050"></a>00050 <span class="comment">// */</span>
<a name="l00051"></a>00051 <span class="comment">//void WARNING(char *error, ...);</span>
<a name="l00052"></a>00052 <span class="comment">//</span>
<a name="l00054"></a>00054 <span class="comment"></span><span class="comment">// * Responsible for freeing the memory in an array of strings that have been alloc&#39;d. Also frees the array pointer.</span>
<a name="l00055"></a>00055 <span class="comment">// * @param array a pointer to the array of pointers to be freed.</span>
<a name="l00056"></a>00056 <span class="comment">// * @param count the number of elements in the array to be freed.</span>
<a name="l00057"></a>00057 <span class="comment">// * @return On success, the total number of characters written. On failure, a negative number is returned.</span>
<a name="l00058"></a>00058 <span class="comment">// */</span>
<a name="l00059"></a>00059 <span class="comment">//void free_char_ptr_array(/*@null@*/ char ***array, int count);</span>
<a name="l00060"></a>00060 <span class="comment">//</span>
<a name="l00062"></a>00062 <span class="comment"></span><span class="comment">// * Converts a path into an array of tokens. The path is delimated using the &quot;/&quot; character and each token is inserted into an array. The number of elements in the array is returned and the pointer passed in by the user will be allocated for the array of elements. The caller is responsible for freeing both the array pointer, and the pointers of each token in the array. The function free_char_ptr_array can be used for this purpose.</span>
<a name="l00063"></a>00063 <span class="comment">// * @param path a string representing a path in the file system.</span>
<a name="l00064"></a>00064 <span class="comment">// * @param array a pointer to an array of strings (char pointers).</span>
<a name="l00065"></a>00065 <span class="comment">// * </span>
<a name="l00066"></a>00066 <span class="comment">// */</span>
<a name="l00067"></a>00067 <span class="comment">//int path_to_array(const char *path, char ***array);</span>
<a name="l00068"></a>00068 <span class="comment">//</span>
<a name="l00070"></a>00070 <span class="comment"></span><span class="comment">// * Counts the number of tags in a path. Uses the standand path delimiter &quot;/&quot; to calculate the total. Function uses strtok, but does not modify the path that is passed in as a parameter.</span>
<a name="l00071"></a>00071 <span class="comment">// * @param path a string representing a path in the file system.</span>
<a name="l00072"></a>00072 <span class="comment">//const int num_tags_in_path(const char* path);</span>
<a name="l00073"></a>00073 <span class="comment">// * @return the number of path elements delimited by the &quot;/&quot; character.</span>
<a name="l00074"></a>00074 <span class="comment">// */</span>
<a name="l00075"></a>00075 <span class="comment">//int num_tags_in_path(const char* path);</span>
<a name="l00076"></a>00076 <span class="comment">//</span>
<a name="l00078"></a>00078 <span class="comment"></span><span class="comment">// * Checks if a string is contained within an array. Expects a count parameter to be passed in representing the length of the array.</span>
<a name="l00079"></a>00079 <span class="comment">// * @param array the array the check</span>
<a name="l00080"></a>00080 <span class="comment">// * @param string the string to check for</span>
<a name="l00081"></a>00081 <span class="comment">// * @return true, if the string is in the array. false, if the string is not in the array.</span>
<a name="l00082"></a>00082 <span class="comment">// */</span>
<a name="l00083"></a>00083 <span class="comment">//bool array_contains_string(/*@out@*/ char **array, char *string, int count);</span>
<a name="l00084"></a>00084 <span class="comment">//</span>
<a name="l00086"></a>00086 <span class="comment"></span><span class="comment">// * Checks if a file is valid. If the files returned from a query contain the file that is being checked, then the file is assumed to be valid.</span>
<a name="l00087"></a>00087 <span class="comment">// * @param path a string representing a path in the file system</span>
<a name="l00088"></a>00088 <span class="comment">// * @return true, if the file is valid. false, if the file is not valid.</span>
<a name="l00089"></a>00089 <span class="comment">// **/</span>
<a name="l00090"></a>00090 <span class="comment">//bool valid_path_to_file(const char *path);</span>
<a name="l00091"></a>00091 <span class="comment">//</span>
<a name="l00093"></a>00093 <span class="comment"></span><span class="comment">// * Checks whether or not a given path is valid. This is specifically done by checking that every component of the path is valid and that every component is unique. Essentially, this is done with calls to valid_tags_in_path and unique_path.</span>
<a name="l00094"></a>00094 <span class="comment">// * @param path a string representing a path in the file system.</span>
<a name="l00095"></a>00095 <span class="comment">// * @return true, if the path is valid. false, if the path is not valid.</span>
<a name="l00096"></a>00096 <span class="comment">// */</span>
<a name="l00097"></a>00097 <span class="comment">//bool valid_path_to_tag(const char *path);</span>
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Jan 22 2011 14:40:00 for TagFS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
